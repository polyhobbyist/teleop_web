<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <script type="text/javascript" src="https://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
    <script type="text/javascript" src="https://static.robotwebtools.org/roslibjs/current/roslib.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>

    <style>
        html,
        body {
          overflow: hidden;
          width: 100%;
          height: 100%;
          margin: 0;
          padding: 0;
        }
  
        #renderCanvas {
          width: 100%;
          height: 100%;
          touch-action: none;
        }
      </style>
</head>
          


<body>
    <canvas id="renderCanvas" touch-action="none"></canvas>    


    <script type="text/javascript" type="text/javascript">

        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
          
          
      // Connecting to ROS
      // -----------------
    
      
    
      var ros = new ROSLIB.Ros({
        url : 'wss://' + window.location.hostname + ':9090'
      });
    
      ros.on('connection', function() {
        console.log('Connected to websocket server.');
      });
    
      ros.on('error', function(error) {
        console.log('Error connecting to websocket server: ', error);
      });
    
      ros.on('close', function() {
        console.log('Connection to websocket server closed.');
      });
    
      // Publishing a Topic
      // ------------------
    
      var joyPub = new ROSLIB.Topic({
        ros : ros,
        name : '/joy',
        messageType : 'sensor_msgs/Joy'
      });

      var aDown = false;
      var bDown = false;
      var xDown = false;
      var yDown = false;

      var xLeftPos = 0;
      var yLeftPos = 0;

      var sideJoystickOffset = 0;
      var bottomJoystickOffset = 0;

      var leftJoystick = null;
    
      const CreateTeleopScene = async function () {
        const scene = new BABYLON.Scene(engine);

        var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);        
    

        let advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("GUI", true, scene);
        let loadedGUI = await advancedTexture.parseFromURLAsync("/joystick_gui.json", true);

        let left_puck = advancedTexture.getControlByName("Left_Puck");
        let left_thumb = advancedTexture.getControlByName("Left_ThumbContainer");
        let left_inner_thumb = advancedTexture.getControlByName("Left_InnerThumb");

        left_inner_thumb.isPointerBlocker = true;
        left_thumb.isPointerBlocker = true;
        left_puck.isPointerBlocker = true;

        sideJoystickOffset = left_thumb.left;
        bottomJoystickOffset = left_thumb.top;
        
        left_thumb.onPointerDownObservable.add(function(coordinates) {
          left_puck.isVisible = true;
          left_puck.floatLeft = coordinates.x-(left_thumb._currentMeasure.width*.5)-sideJoystickOffset;
          left_puck.left = left_puck.floatLeft;
          left_puck.floatTop = loadedGUI._canvas.height - coordinates.y-(left_thumb._currentMeasure.height*.5)+bottomJoystickOffset;
          left_puck.top = left_puck.floatTop*-1;
          left_puck.isDown = true;
          left_thumb.alpha = 0.9;
        });

        left_thumb.onPointerUpObservable.add(function(coordinates) {
            xAddPos = 0;
            yAddPos = 0;
            left_puck.isDown = false;
            left_puck.isVisible = false;
            left_thumb.alpha = 0.4;
        });


        left_thumb.onPointerMoveObservable.add(function(coordinates) {
            if (left_puck.isDown) {
                xAddPos = coordinates.x-(left_thumb._currentMeasure.width*.5)-sideJoystickOffset;
                yAddPos = loadedGUI._canvas.height - coordinates.y-(left_thumb._currentMeasure.height*.5)+bottomJoystickOffset;
                left_puck.floatLeft = xAddPos;
                left_puck.floatTop = yAddPos*-1;
                left_puck.left = left_puck.floatLeft;
                left_puck.top = left_puck.floatTop;
              }
        });


        let a = advancedTexture.getControlByName("A_Button");
        let b = advancedTexture.getControlByName("B_Button");
        let x = advancedTexture.getControlByName("X_Button");
        let y = advancedTexture.getControlByName("Y_Button");

        
        a.onPointerDownObservable.add(() => {aDown = true});        
        a.onPointerUpObservable.add(() => {aDown = false});        

        b.onPointerDownObservable.add(() => {bDown = true});        
        b.onPointerUpObservable.add(() => {bDown = false});        

        x.onPointerDownObservable.add(() => {xDown = true});        
        x.onPointerUpObservable.add(() => {xDown = false});        

        y.onPointerDownObservable.add(() => {yDown = true});        
        y.onPointerUpObservable.add(() => {yDown = false});        

        engine.runRenderLoop(function () {
            if (scene != null) {
              scene.render();
            }
          });
    
       
        return scene;    
      }
    
      window.addEventListener("gamepadconnected", (event) => {
        // if we have a gamepad, disable the screen controller
        BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1";
        console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
            event.gamepad.index, event.gamepad.id,
            event.gamepad.buttons.length, event.gamepad.axes.length);
      });
    
      window.addEventListener("gamepaddisconnected", (event) => {
        // if we don't have a gamepad, enable the screen controller
        BABYLON.VirtualJoystick.Canvas.style.zIndex = "4";
      });
    
      var currentScene = CreateTeleopScene();

      var interval = setInterval(function () {
        const [gp] = navigator.getGamepads();


        if (gp != null) {
            var leftTrigger = 0.0;
            if (gp.buttons[6].pressed) {
                leftTrigger = 1.0;
            }

            var rightTrigger = 0.0;
            if (gp.buttons[6].pressed) {
                rightTrigger = 1.0;
            }

            var joyMsg = new ROSLIB.Message({
                axes: [gp.axes[0], gp.axes[1], leftTrigger, gp.axes[2], gp.axes[3], rightTrigger],
                buttons: [gp.buttons[0].pressed, gp.buttons[1].pressed, gp.buttons[2].pressed, gp.buttons[3].pressed, gp.buttons[4].pressed, gp.buttons[5].pressed, gp.buttons[8].pressed, gp.buttons[9].pressed, gp.buttons[10].pressed, gp.buttons[11].pressed],
            });

            joyPub.publish(joyMsg);
        } else if (leftJoystick != null) {
            var left_LeftRight = xAddPos/3000;
            var left_UpDown = yAddPos/3000;
            
            var joyMsg = new ROSLIB.Message({
              axes: [left_LeftRight, left_UpDown, 0.0, 0.0, 0.0, 0.0],
              buttons: [aDown, bDown, xDown, yDown, false, false, false, false, leftJoystick.pressed, false],
            });

            joyPub.publish(joyMsg);

        }
      }, 20);
    
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
            engine.resize();
        });  
    
    </script>
</body>
</html>